continue
validator.validate.errors(full: true)
validator.validate.errors
validator.validate
continue
validator.validate.errors(full: true)
validator.validate.errors
validator.validate
validator
continue
validator.validate
validator
continue
n
s
validator.validate.errors(full: true)
validator.validate.errors
continue
validator.validate.errors(full: true)
validator.validate.errors
continue
validator.validate.errors
validator.validate
continue
validator.validate.errors(full: true)
continue
self
messages.rule('テスト')
rule
messages.rule(rule, opts)
messages.rule
messages
n
full?
n
template
teampltea
teamplate
template
tokens
rule
tokens
template
text
s
message_text(rule, template, tokens, options)
options
tokens
template
rule
n
template
n
path
rule
n
options.update(tokens)
n
base_opts.update(lookup_options(arg_vals: arg_vals, input: input))
input
n
message_tokens(args)
n
val
arg_vals
n
args.map(&:last)
args
predicate
n
s
n
s
merge(other.update(path: [*path, *other[:path]]))
s
other
oTHer
rule
n
s
args
node[1]
node
s
n
s
merge(other.update(path: [*path, *other[:path]]))
s
visit(other, opts.(rule: rule))
n
s
n
s
n
s
n
s
continue
left
n
right
left
s
node
self.dump
self
node
n
merge(other.update(path: [*path, *other[:path]]))
other
s
visit(other, opts.(rule: rule))
other
rule
n
node
s
node[0]
args
node
s
n
s
n
s
n
s
continue
messages.flatten
messages
n
__send__(:"visit_#{node[0]}", node[1], *args)
s
ast
MessageSet[ast.map { |node| visit(node) }, failures: options.fetch(:failures, true)].dump
MessageSet[ast.map { |node| visit(node) }, failures: options.fetch(:failures, true)]
n
results.map(&:to_ast)
n
self
options
messages
s
self
n
s
message_compiler.with(options).(result_ast).dump
message_compiler.with(options).(result_ast)
s
message_set(options.merge(hints: false)).dump
message_set(options.merge(hints: false))
n
s
continue
n
ast
n
results.map(&:to_ast)
results
n
s
messages
self
n
new_options
s
options
n
step
h
